{"files":[{"path":["/","mnt","l","Projects","ptero-cli","src","bin","main.rs"],"content":"use std::{error::Error, fs::File, io::Write};\n\nuse clap::{ArgGroup, Clap};\nuse log::info;\n\nuse ptero::{\n    cli::decoder::decode_command,\n    cli::{\n        capacity::get_cover_text_capacity, capacity::GetCapacityCommand, decoder::DecodeSubCommand,\n        encoder::EncodeSubCommand, writer::get_writer,\n    },\n    log::{get_file_logger, get_stdout_logger, verbosity_to_level_filter},\n};\n\nconst BANNER: &str = r#\"\n\n     ______   ______   ______     ______     ______    \n    /\\  == \\ /\\__  _\\ /\\  ___\\   /\\  == \\   /\\  __ \\   \n    \\ \\  _-/ \\/_/\\ \\/ \\ \\  __\\   \\ \\  __<   \\ \\ \\/\\ \\  \n     \\ \\_\\      \\ \\_\\  \\ \\_____\\  \\ \\_\\ \\_\\  \\ \\_____\\ \n      \\/_/       \\/_/   \\/_____/   \\/_/ /_/   \\/_____/ \n                                                    \n\"#;\n\nconst APP_NAME: &str = \"Ptero CLI\";\n\n/// The CLI text steganography tool for social media.\n#[derive(Clap)]\n#[clap(\nversion = \"0.2\",\nauthor = \"PaweÅ‚ G. <dev.baymax42@gmail.com>\",\nname = format ! (\"{}{}\", BANNER, APP_NAME),\ngroup = ArgGroup::new(\"output_args\").required(false),\n)]\nstruct Opts {\n    #[clap(subcommand)]\n    subcommand: SubCommand,\n\n    /// Path to file where the result of encoding/decoding should be placed.\n    /// If not used, it will print to stdout.\n    ///\n    /// Cannot be used in conjunction with `--json` flag.\n    #[clap(short, long, group = \"output_args\")]\n    output: Option<String>,\n\n    /// Flag for controlling verbosity of the output logs.\n    ///\n    /// To increase verbosity add additional occurrences e.g. `-vv` will print info logs.\n    /// By default only error logs are printed.\n    #[clap(short, parse(from_occurrences))]\n    verbose: u8,\n    /// If present, will print the output of the CLI in JSON format that can be further parsed by other tooling.\n    ///\n    /// Cannot be used in conjunction with `-o` flag.\n    #[clap(long, group = \"output_args\")]\n    json: bool,\n    /// Path to log file.\n    ///\n    /// By default CLI won't save any logs. If this param is used, CLI will append new logs at the end of the file\n    /// pointed by the path. It is not affected by the `verbose` flag, and saves all the entries (starting from `TRACE`).\n    #[clap(long)]\n    log_file: Option<String>,\n}\n\n#[derive(Clap)]\nenum SubCommand {\n    #[clap(name = \"encode\", group = ArgGroup::new(\"method_args\").required(true))]\n    Encode(EncodeSubCommand),\n    #[clap(name = \"decode\", group = ArgGroup::new(\"method_args\").required(true))]\n    Decode(DecodeSubCommand),\n    #[clap(name = \"capacity\")]\n    GetCapacity(GetCapacityCommand),\n}\n\nfn enable_logging(\n    verbose: u8,\n    log_path: Option<String>,\n) -> std::result::Result<(), Box<dyn Error>> {\n    let level_filter = verbosity_to_level_filter(verbose);\n    let mut log_builder = fern::Dispatch::new().chain(get_stdout_logger(level_filter));\n\n    log_builder = if let Some(path) = log_path {\n        log_builder.chain(get_file_logger(&path))\n    } else {\n        log_builder\n    };\n\n    log_builder.apply()?;\n    Ok(())\n}\n\nfn run_subcommand(subcommand: SubCommand) -> Result<Vec<u8>, Box<dyn Error>> {\n    let result = match subcommand {\n        SubCommand::Encode(command) => {\n            command.run()?\n        }\n        SubCommand::Decode(command) => {\n            decode_command(command)?\n        }\n        SubCommand::GetCapacity(command) => {\n            let capacity: u32 = get_cover_text_capacity(command)?;\n            let output_str = format!(\"{} b\", capacity);\n            output_str.as_bytes().into()\n        }\n    };\n    Ok(result)\n}\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let opts: Opts = Opts::parse();\n\n    enable_logging(opts.verbose, opts.log_file)?;\n    let writer = get_writer(opts.json);\n    writer.message(BANNER);\n\n    let result = run_subcommand(opts.subcommand);\n\n    if let Err(error) = &result {\n        let error_message = format!(\"{}\", error);\n        writer.output(&error_message);\n    } else {\n        let cli_output = &result?;\n        if let Some(path) = &opts.output {\n            let mut output_file = File::create(path)?;\n            output_file.write_all(&cli_output)?;\n            info!(\"Saved to '{}'\", &path);\n        } else {\n            writer.output(&String::from_utf8_lossy(&cli_output));\n        }\n    }\n    Ok(())\n}\n","traces":[{"line":75,"address":[4229024,4229096],"length":1,"stats":{"Line":0},"fn_name":"enable_logging"},{"line":79,"address":[4229116,4229039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[4229132,4229859],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[4229224,4229272,4229550,4229937],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[4229313,4229895,4229484],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[4229243],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[4229559,4229666,4229713,4230027],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[4229627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[4231684,4230288],"length":1,"stats":{"Line":0},"fn_name":"run_subcommand"},{"line":93,"address":[4230436,4231587,4231058,4230798],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[4230298,4230443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[4230595,4230675,4230749,4230576,4230503,4230794],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[4230808],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[4230968,4231063,4230844],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[4230350],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[4231285,4231171,4230374],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[4231382,4231230],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[4231511],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[4231589],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[4231824,4231870],"length":1,"stats":{"Line":0},"fn_name":"main"},{"line":110,"address":[4231831],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[4231885,4234808,4232203,4232096],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[4232058,4232271],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[4232295],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[4232352,4232481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[4232570,4232937,4232489,4234627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[4232594],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[4232793],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[4232500,4232942,4233300,4233139],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[4233405,4233083,4234467,4234606],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[4233545,4233413,4233704],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[4234094,4233728,4233507,4233959],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[4233918,4234099,4234182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[4233324,4234472],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[4234629],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":35},{"path":["/","mnt","l","Projects","ptero-cli","src","binary.rs"],"content":"use std::{error::Error, convert::TryFrom};\nuse std::{fmt, vec::Vec};\n\nconst MOST_SIGNIFICANT_BIT_PATTERN: u8 = 0b10000000;\nconst CLEARED_PATTERN: u8 = 0b00000000;\n/// Type for representing a bit.\n#[derive(Debug, PartialOrd, PartialEq, Clone)]\npub struct Bit(pub u8);\n\n/// Wrapper for `Vec<Bit>` used for implementing `From` trait.\npub struct BitVec(Vec<Bit>);\n\nimpl From<BitVec> for Vec<Bit> {\n    fn from(bit_vec: BitVec) -> Self {\n        bit_vec.0\n    }\n}\n\nimpl From<Vec<Bit>> for BitVec {\n    fn from(bit_vec: Vec<Bit>) -> Self {\n        BitVec(bit_vec)\n    }\n}\n\nimpl From<BitVec> for u32 {\n    /// Conversion implementation for `u32`.\n    /// Converts array of [Bits](Bit) to the corresponding number. The function\n    /// expects that the first element is the most significant bit.\n    ///\n    /// # Examples\n    ///\n    /// ## Convert 5 bits to number\n    /// ```\n    /// use ptero::binary::{Bit, BitVec};\n    ///\n    /// let array: BitVec = vec![1, 0, 1, 1, 1]\n    ///                         .iter()\n    ///                         .map(|v| Bit(*v))\n    ///                         .collect::<Vec<Bit>>()\n    ///                         .into();\n    /// let number: u32 = array.into();\n    /// assert_eq!(number, 23);\n    /// ```   \n    fn from(bit_vec: BitVec) -> Self {\n        let mut number: u32 = 0;\n        for bit in bit_vec.0.into_iter() {\n            number <<= 1;\n            number += u32::from(bit.0);\n        }\n        number \n    }\n}\n\nimpl From<u32> for BitVec {\n    /// Conversion implementation for `u32`.\n    /// Converts `u32` number to the vector of [Bits](Bit). \n    /// The result vector has the most significant bit at the beginning.\n    ///\n    /// # Examples\n    ///\n    /// ## Convert the 65 number\n    /// ```\n    /// use ptero::binary::{Bit, BitVec};\n    ///\n    /// let array: BitVec = vec![1, 0, 1, 1, 1]\n    ///                         .iter()\n    ///                         .map(|v| Bit(*v))\n    ///                         .collect::<Vec<Bit>>()\n    ///                         .into();\n    /// let number: u32 = array.into();\n    /// assert_eq!(number, 23);\n    /// ```   \n    fn from(number: u32) -> Self {\n        let byte_array = [\n            ((number >> 24) & 0xff) as u8,\n            ((number >> 16) & 0xff) as u8,\n            ((number >> 8) & 0xff) as u8,\n            (number & 0xff) as u8\n        ];\n        BitIterator::new(&byte_array).collect::<Vec<Bit>>().into()\n    }\n}\n\nimpl TryFrom<BitVec> for Vec<u8> {\n    type Error = BinaryConversionError;\n\n    /// Tries to convert array of [Bits](Bit) to the array of bytes. The function\n    /// expects that each left most bit in byte-size boundary is the \n    /// most significant bit.\n    ///\n    /// # Arguments\n    ///\n    /// * `bits` - reference to array of bits `&[Bit]`\n    /// \n    /// # Behavior\n    /// \n    /// Function return [BinaryConversionError] when\n    /// array is not padded to byte-size boundary i.e. length to divisible by 8. \n    ///\n    /// # Examples\n    ///\n    /// ## Convert 16 bits to 2 bytes\n    /// ```\n    /// use ptero::binary::{Bit, BitVec, BinaryConversionError};\n    /// use std::convert::TryFrom;\n    /// \n    /// let array: BitVec = vec![0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1]\n    ///                             .iter()\n    ///                             .map(|v| Bit(*v))\n    ///                             .collect::<Vec<Bit>>()\n    ///                             .into();\n    /// let result: Result<Vec<u8>, BinaryConversionError> = TryFrom::try_from(array);\n    /// assert!(result.is_ok());\n    /// assert_eq!(result.unwrap(), vec![42, 129]);\n    /// ```      \n    /// \n    /// ## Return error if array is not in byte-size boundary\n    /// ```\n    /// use ptero::binary::{Bit, BinaryConversionError, BitVec};\n    /// use std::convert::TryFrom;\n    ///\n    /// let array: BitVec = vec![0, 0, 1]\n    ///                             .iter()\n    ///                             .map(|v| Bit(*v))\n    ///                             .collect::<Vec<Bit>>()\n    ///                             .into();\n    /// let result: Result<Vec<u8>, BinaryConversionError> = TryFrom::try_from(array);\n    /// assert!(!result.is_ok());\n    /// ``` \n    fn try_from(bit_vec: BitVec) -> Result<Vec<u8>, Self::Error> {\n        let mut bytes = Vec::<u8>::default();\n        let mut index = 0;\n        if bit_vec.0.len() % 8 != 0 {\n            return Err(BinaryConversionError::new(\n                \"Bit array length is not divisible by 8\".to_string(),\n            ));\n        }\n        while index < bit_vec.0.len() {\n            let mut byte = 0;\n            for _ in 0..8 {\n                byte *= 2;\n                byte += bit_vec.0.get(index).unwrap().0;\n                index += 1;\n            }\n            bytes.push(byte);\n        }\n        Ok(bytes)\n    }\n}\n\nimpl fmt::Display for Bit {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n/// Error signaling binary conversion issues. Used in `From` trait implementation.\n#[derive(Debug, Clone)]\npub struct BinaryConversionError {\n    message: String,\n}\n\nimpl BinaryConversionError {\n    fn new(message: String) -> Self {\n        BinaryConversionError { message }\n    }\n}\n\nimpl fmt::Display for BinaryConversionError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"Binary conversion error\")\n    }\n}\n\nimpl Error for BinaryConversionError {}\n\n#[derive(Debug)]\nstruct BinaryPattern(u8);\n\nimpl BinaryPattern {\n    fn new() -> BinaryPattern {\n        BinaryPattern(MOST_SIGNIFICANT_BIT_PATTERN)\n    }\n\n    fn start(&mut self) {\n        self.0 = MOST_SIGNIFICANT_BIT_PATTERN;\n    }\n\n    fn is_cleared(&self) -> bool {\n        self.0 == CLEARED_PATTERN\n    }\n\n    fn shift(&mut self) {\n        self.0 >>= 1;\n    }\n\n    fn get(&self, byte: u8) -> Bit {\n        match byte & self.0 {\n            0 => Bit(0),\n            _ => Bit(1),\n        }\n    }\n}\n\n/// [Bit] sequence iterator.\n/// It enables user to read [Bits](Bit) from any iterator that provides bytes as `u8`.\n#[derive(Debug)]\npub struct BitIterator<'a> {\n    bytes: &'a [u8],\n    index: usize,\n    fetch_pattern: BinaryPattern,\n}\n\nimpl<'a> BitIterator<'a> {\n    /// Creates a [Bit] iterator for specified byte array.\n    ///\n    /// **Please note that it begins iteration from the MSB.**\n    ///\n    /// # Arguments\n    ///\n    /// * `array` - reference to array of bytes `&[u8]`\n    ///\n    /// # Examples\n    ///\n    /// ## Returns optional value\n    /// ```\n    /// use ptero::binary::{Bit, BitIterator};\n    ///\n    /// let array: Vec<u8> = vec!(1, 0, 2, 3);\n    /// let mut iterator = BitIterator::new(&array);\n    ///\n    /// let bit = iterator.next().unwrap();\n    /// let Bit(value) = bit;\n    /// assert_eq!(value, 0);\n    /// ```    \n    ///\n    /// ## Repeats itself after reaching the end\n    /// ```\n    /// use ptero::binary::{Bit, BitIterator};\n    ///\n    /// let array: Vec<u8> = vec!(0);\n    /// let mut iterator = BitIterator::new(&array);\n    ///\n    /// for v in &mut iterator {\n    ///     assert_eq!(v, Bit(0));\n    /// }\n    /// iterator.next();\n    /// for v in &mut iterator {\n    ///     assert_eq!(v, Bit(0));\n    /// }\n    /// ```    \n    ///\n    ///\n    pub fn new(array: &'a [u8]) -> Self {\n        // At the first execution we'll fetch the first value and then process it\n        BitIterator {\n            bytes: array,\n            index: 0,\n            fetch_pattern: BinaryPattern::new(),\n        }\n    }\n}\n\nimpl<'a> Iterator for BitIterator<'a> {\n    type Item = Bit;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.fetch_pattern.is_cleared() {\n            self.fetch_pattern.start();\n            self.index += 1;\n        };\n        let byte = *self.bytes.get(self.index)?;\n        let bit = self.fetch_pattern.get(byte);\n        self.fetch_pattern.shift();\n        Some(bit)\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":48,"coverable":56},{"path":["/","mnt","l","Projects","ptero-cli","src","cli","capacity.rs"],"content":"use clap::Clap;\nuse log::{error, info, warn};\nuse std::{error::Error, fs};\n\nuse crate::{\n    context::{Context, PivotByLineContext},\n    encoder::Encoder,\n    method::complex::extended_line::ExtendedLineMethod,\n};\n\nuse super::encoder::determine_pivot_size;\n\n/// Calculate the minimal capacity for the cover text and given pivot\n#[derive(Clap)]\npub struct GetCapacityCommand {\n    /// Path to cover text.\n    #[clap(short, long)]\n    cover: String,\n\n    /// Pivot i.e. line length.\n    #[clap(short, long)]\n    pivot: usize,\n}\n\npub fn get_cover_text_capacity(args: GetCapacityCommand) -> Result<u32, Box<dyn Error>> {\n    let cover_text = fs::read_to_string(args.cover)?;\n    let mut pivot_word_context = PivotByLineContext::new(&cover_text, args.pivot);\n    let mut lines_count = 0;\n\n    let max_word_length = determine_pivot_size(cover_text.split_whitespace());\n    let text_length = cover_text\n        .split_whitespace()\n        .map(|string| string.chars())\n        .flatten()\n        .count();\n    info!(\"Longest word in the cover text is {}\", max_word_length);\n\n    if max_word_length > args.pivot {\n        warn!(\"This pivot might not guarantee the secret data will be encodable!\");\n    } else if args.pivot >= text_length {\n        error!(\"Pivot greater than the cover text length, stopping\");\n        return Err(\"Could not determine the capacity for the given cover text\".into());\n    }\n\n    info!(\"Calculating the capacity\");\n    while let Ok(line) = pivot_word_context.load_text() {\n        if line.is_empty() {\n            error!(\"Pivot is too small, stopping\");\n            return Err(\"Could not determine the capacity for the given cover text\".into());\n        }\n        lines_count += 1;\n    }\n    let encoder = ExtendedLineMethod::default();\n    Ok(lines_count * encoder.rate())\n}\n","traces":[{"line":25,"address":[4319600,4319698],"length":1,"stats":{"Line":0},"fn_name":"get_cover_text_capacity"},{"line":26,"address":[4319957,4319713,4319610,4319852],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[4319993,4319826],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[4320028],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[4320127,4320047],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[4320166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[4221251,4221232],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":36,"address":[4534596,4534463],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[4534880,4535238],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[4535066,4534933],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[4534918],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[4535248,4535381],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[4535553,4535651],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[4535777,4535656],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[4535937,4536026,4536459],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[4536042],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[4536218,4536097],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[4536378],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[4536737,4536066,4536767,4536452],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[4536004],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[4536464,4536705,4536559],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":21},{"path":["/","mnt","l","Projects","ptero-cli","src","cli","decoder.rs"],"content":"use std::{error::Error, fs};\n\nuse clap::Clap;\n\nuse crate::{\n    context::PivotByRawLineContext,\n    decoder::Decoder,\n    method::complex::{eluv::ELUVMethod, extended_line::ExtendedLineMethod},\n};\n\n/// Decode secret from the stegotext\n#[derive(Clap)]\npub struct DecodeSubCommand {\n    /// Path to stegotext from which data will be decoded\n    #[clap(short, long)]\n    text: String,\n    /// Pivot i.e. line length used to encode with extended line algorithm\n    #[clap(short, long)]\n    pivot: usize,\n    #[clap(long, group = \"method_args\")]\n    /// Use ELUV method for encoding.\n    eluv: bool,\n    /// Use Extended Line method for encoding.\n    #[clap(long = \"eline\", group = \"method_args\")]\n    #[allow(dead_code)]\n    extended_line: bool,\n}\n\npub fn get_method(eluv: bool) -> Box<dyn Decoder<PivotByRawLineContext>> {\n    if eluv {\n        Box::new(ELUVMethod::default())\n    } else {\n        Box::new(ExtendedLineMethod::default())\n    }\n}\n\npub fn decode_command(args: DecodeSubCommand) -> Result<Vec<u8>, Box<dyn Error>> {\n    let cover_text = fs::read_to_string(args.text)?;\n    let decoder = get_method(args.eluv);\n    let mut context = PivotByRawLineContext::new(cover_text.as_str(), args.pivot);\n\n    Ok(decoder.decode(&mut context)?)\n}\n","traces":[{"line":29,"address":[4563456],"length":1,"stats":{"Line":0},"fn_name":"get_method"},{"line":30,"address":[4563570,4563641,4563469],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[4563488,4563560],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[4563475,4563631],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[4563664,4563754],"length":1,"stats":{"Line":0},"fn_name":"decode_command"},{"line":38,"address":[4563769,4563674,4563968,4563892],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[4563867,4564017],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[4564043],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[4564545,4564406,4564131,4564214,4564284],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":9},{"path":["/","mnt","l","Projects","ptero-cli","src","cli","encoder.rs"],"content":"use std::{\n    error::Error,\n    fs::{File},\n    io::Read,\n};\n\nuse clap::Clap;\nuse log::{error, info, trace, warn};\n\nuse crate::{\n    binary::BitIterator,\n    context::PivotByLineContext,\n    encoder::Encoder,\n    method::complex::{eluv::ELUVMethod, extended_line::ExtendedLineMethod},\n};\n\n/// Encode the secret into given cover text\n#[derive(Clap)]\npub struct EncodeSubCommand {\n    /// Path to cover text used to encoding.\n    ///\n    /// Please note that original whitespace may not be preserved!\n    #[clap(short, long)]\n    cover: String,\n\n    /// Path to secret data file which will be encoded.\n    #[clap(short, long)]\n    data: String,\n\n    /// Pivot i.e. line length used for extended line algorithm.\n    ///\n    /// If omitted, program will determine minimum pivot that can be used.\n    #[clap(long)]\n    pivot: Option<usize>,\n    /// Use ELUV method for encoding.\n    ///\n    /// The ELUV method is a combination of three smaller encoders. \n    /// Random Whitespace - which puts randomly double whitepsace between words,\n    /// Line Extend - which uses pivot to determine the size of the line,\n    /// Trailing Unicode - which puts one of the predefined Unicode invisible chars\n    /// at the end of the line during encoding.\n    ///\n    /// It can encode 7 bits in one pass.\n    #[clap(long, group = \"method_args\")]\n    eluv: bool,\n    /// Use Extended Line method for encoding.\n    ///\n    /// The Extended Line method is a combination of three smaller encoders.\n    /// Random Whitespace - which puts randomly double whitepsace between words,\n    /// Line Extend - which uses pivot to determine the size of the line,\n    /// Trailing Whitespace - which puts whitespace at the end of the line during encoding.\n    ///\n    /// It can encode 3 bits in one pass. Relies purely on ASCII characters.\n    #[clap(long = \"eline\", group = \"method_args\")]\n    #[allow(dead_code)]\n    extended_line: bool,\n}\n\nimpl EncodeSubCommand {\n    pub fn run(&self) -> Result<Vec<u8>, Box<dyn Error>> {\n        let cover_file_input = File::open(&self.cover)?;\n        let data_file_input = File::open(&self.data)?;\n\n        self.do_encode(cover_file_input, data_file_input)\n    }\n\n    pub(crate) fn do_encode(\n        &self,\n        mut cover_input: impl Read,\n        mut data_input: impl Read,\n    ) -> Result<Vec<u8>, Box<dyn Error>> {\n        let mut cover_text = String::new();\n        let mut data = vec![];\n\n        cover_input.read_to_string(&mut cover_text)?;\n        data_input.read_to_end(&mut data)?;\n        \n        trace!(\"text: {:?}\", data);\n\n        let pivot = pick_pivot_from(\n            self.pivot,\n            determine_pivot_size(cover_text.split_whitespace()),\n        )?;\n\n        warn!(\n            \"Required cover text capacity: {}\",\n            BitIterator::new(&data).count()\n        );\n        info!(\"Encoding secret data\");\n\n        let mut data_iterator = BitIterator::new(&data);\n        let method = self.get_method();\n        let mut context = PivotByLineContext::new(&cover_text, pivot);\n        let stego_result = method.encode(&mut context, &mut data_iterator);\n\n        Ok(stego_result?.as_bytes().into())\n    }\n\n    pub(crate) fn get_method(&self) -> Box<dyn Encoder<PivotByLineContext>> {\n        if self.eluv {\n            Box::new(ELUVMethod::default())\n        } else {\n            Box::new(ExtendedLineMethod::default())\n        }\n    }\n}\n\npub(crate) fn determine_pivot_size<'a>(words: impl Iterator<Item = &'a str>) -> usize {\n    words\n        .into_iter()\n        .map(|string| string.chars().count() + 1)\n        .max()\n        .unwrap_or(0)\n}\n\npub(crate) fn pick_pivot_from(\n    user_pivot: Option<usize>,\n    calculated_pivot: usize,\n) -> Result<usize, Box<dyn Error>> {\n    Ok(if let Some(value) = user_pivot {\n        if value < calculated_pivot {\n            error!(\"Provided pivot is smaller than the largest word in text! Cannot guarantee encoding will succeed.\");\n            return Err(\"stub\".into());\n        }\n        info!(\"Using user provided pivot: {}\", value);\n        value\n    } else {\n        info!(\"Using pivot based on the cover text: {}\", calculated_pivot);\n        calculated_pivot\n    })\n}\n\n#[allow(unused_imports)]\nmod test {\n    use std::{error::Error, io::Read};\n\n    use super::EncodeSubCommand;\n\n    #[test]\n    fn fails_when_there_is_not_enough_cover_text() -> Result<(), Box<dyn Error>> {\n        let cover_input = \"a b c \".repeat(2);\n        let data_input: Vec<u8> = vec!(0b11111111);\n\n        let command = EncodeSubCommand {\n            cover: \"stub\".into(),\n            data: \"stub\".into(),\n            pivot: Some(3),\n            eluv: false,\n            extended_line: true,\n        };\n\n        let result = command.do_encode(cover_input.as_bytes(), data_input.as_slice());\n        assert!(result.is_err());\n        Ok(())\n    }\n\n    #[test]\n    fn fails_when_pivot_is_too_small() -> Result<(), Box<dyn Error>> {\n        let cover_input = \"aaaaa \".repeat(2);\n        let data_input: Vec<u8> = vec!(0b11111111);\n\n        let command = EncodeSubCommand {\n            cover: \"stub\".into(),\n            data: \"stub\".into(),\n            pivot: Some(3),\n            eluv: false,\n            extended_line: true,\n        };\n\n        let result = command.do_encode(cover_input.as_bytes(), data_input.as_slice());\n        assert!(result.is_err());\n        Ok(())\n    }\n}","traces":[{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[4545008,4545042,4544941,4544786,4544854],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[4545063,4545308,4545186,4544915],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[4545139],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[4539482,4539408],"length":1,"stats":{"Line":2},"fn_name":"do_encode<std::fs::File,std::fs::File>"},{"line":72,"address":[4539456],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[4539497],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[4539715,4539875,4539642,4539599,4539800,4539548],"length":1,"stats":{"Line":5},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[4541724],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[4541775],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[4543008],"length":1,"stats":{"Line":1},"fn_name":"determine_pivot_size<core::str::iter::SplitWhitespace>"},{"line":109,"address":[4543015],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[4543171,4543152],"length":1,"stats":{"Line":2},"fn_name":"{{closure}}<core::str::iter::SplitWhitespace>"},{"line":116,"address":[4545696],"length":1,"stats":{"Line":1},"fn_name":"pick_pivot_from"},{"line":120,"address":[4546515,4545721,4546838,4545783],"length":1,"stats":{"Line":5},"fn_name":null},{"line":121,"address":[4545796],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[4545862,4545960],"length":1,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[4546118,4546167],"length":1,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[4545818,4546253,4546189],"length":1,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[4546499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[4546520,4545746,4546584],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[4546825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[4312848,4312888],"length":1,"stats":{"Line":3},"fn_name":"fails_when_there_is_not_enough_cover_text"},{"line":141,"address":[4312862],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[4312908],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[4312960],"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[4312991],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[4313035],"length":1,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[4313312,4313176,4313222],"length":1,"stats":{"Line":3},"fn_name":null},{"line":153,"address":[4313327,4313389],"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[4313365],"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[4313584,4313624],"length":1,"stats":{"Line":3},"fn_name":"fails_when_pivot_is_too_small"},{"line":159,"address":[4313598],"length":1,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[4313644],"length":1,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[4313696],"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[4313727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[4313771],"length":1,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[4314048,4313958,4313912],"length":1,"stats":{"Line":3},"fn_name":null},{"line":171,"address":[4314125,4314063],"length":1,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[4314101],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":46,"coverable":54},{"path":["/","mnt","l","Projects","ptero-cli","src","cli","writer.rs"],"content":"use serde_json::json;\n\npub trait Writer {\n    fn message(&self, data: &str);\n    fn output(&self, data: &str);\n}\n\npub struct JSONWriter;\n\nimpl Writer for JSONWriter {\n    fn message(&self, _data: &str) {}\n\n    fn output(&self, data: &str) {\n        println!(\"{}\", json!({\n            \"type\": \"success\",\n            \"result\": data,\n        }));\n    }\n}\n\npub struct CLIWriter;\n\nimpl Writer for CLIWriter {\n    fn message(&self, data: &str) {\n        println!(\"{}\", data);\n    }\n\n    fn output(&self, data: &str) {\n        println!(\"{}\", data);\n    }\n}\n\npub fn get_writer(json_output: bool) -> Box<dyn Writer> {\n    if json_output {\n        Box::new(JSONWriter)\n    } else {\n        Box::new(CLIWriter)\n    }\n}","traces":[{"line":11,"address":[4426055,4426050,4426032],"length":1,"stats":{"Line":0},"fn_name":"message"},{"line":13,"address":[4426064,4426120],"length":1,"stats":{"Line":0},"fn_name":"output"},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[4661136],"length":1,"stats":{"Line":0},"fn_name":"message"},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[4661456],"length":1,"stats":{"Line":0},"fn_name":"get_writer"},{"line":34,"address":[4661561,4661469,4661537],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[4661527],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[4661494,4661551],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":13},{"path":["/","mnt","l","Projects","ptero-cli","src","context.rs"],"content":"use std::{error::Error, fmt, process};\n\nuse log::error;\n\nuse crate::text::{CoverTextLineIterator, CoverTextWordIterator};\n\n/// Context with essential methods for every encoder/decoder.\npub trait Context {\n    /// Gets currently loaded cover text fragment *mutably*.\n    ///\n    /// # Returns\n    /// Result which is either `&mut String` or [ContextError].\n    fn get_current_text_mut(&mut self) -> Result<&mut String, ContextError>;\n\n    /// Gets currently loaded cover text fragment as read-only.\n    ///\n    /// # Returns\n    /// Result which is either `&String` or [ContextError].\n    fn get_current_text(&self) -> Result<&String, ContextError>;\n\n    /// Loads next cover text fragment.\n    ///\n    /// # Returns\n    /// Result which is either `&String` or [ContextError]. Returned string is the newly loaded fragment.\n    fn load_text(&mut self) -> Result<&String, ContextError>;\n}\n\n/// Context used by methods requiring pivot.\n/// Loads and returns cover text line by line - *not bound by pivot*.\npub struct PivotByRawLineContext {\n    pivot: usize,\n    cover_text_iter: CoverTextLineIterator,\n    current_text: Option<String>,\n}\n/// Context used by methods requiring pivot.\n/// Loads cover text line by line, uses pivot and does not preserve original whitespace.\n/// It also exposes the word iterator for purpose of peeking and/or traversing.\npub struct PivotByLineContext {\n    pivot: usize,\n    cover_text_iter: CoverTextWordIterator,\n    current_text: Option<String>,\n}\n\nimpl PivotByRawLineContext {\n    pub fn new(cover_text: &str, pivot: usize) -> Self {\n        PivotByRawLineContext {\n            pivot,\n            cover_text_iter: CoverTextLineIterator::new(cover_text),\n            current_text: None,\n        }\n    }\n\n    pub fn get_pivot(&self) -> usize {\n        self.pivot\n    }\n}\n\nimpl PivotByLineContext {\n    const WORD_DELIMITER: char = ' ';\n\n    pub fn new(cover_text: &str, pivot: usize) -> Self {\n        PivotByLineContext {\n            pivot,\n            cover_text_iter: CoverTextWordIterator::new(cover_text),\n            current_text: None,\n        }\n    }\n\n    pub fn get_pivot(&self) -> usize {\n        self.pivot\n    }\n\n    // Peeks the next word without forwarding the iterator.\n    //\n    // # Returns\n    // Returns the next word or none if the iterator gets out-of-bounds.\n    pub fn peek_word(&mut self) -> Option<String> {\n        self.cover_text_iter.peek()\n    }\n    \n    // Gets the next word and proceeds the iterator.\n    //\n    // # Returns\n    // Returns the next word or none if the iterator gets out-of-bounds.\n    pub fn next_word(&mut self) -> Option<String> {\n        self.cover_text_iter.next()\n    }\n\n    // Constructs line of maximum length determined by pivot.\n    //\n    // # Returns\n    // Returns the line or none if there are no words left.\n    //\n    // # Panics and exits\n    // Function can crash if pivot is smaller than the length fo the first peeked word.\n    fn construct_line_by_pivot(&mut self) -> Option<String> {\n        // TODO: Refactor to return error instead of process::exit\n        let mut word = self.cover_text_iter.peek()?;\n\n        if word.len() > self.pivot {\n            error!(\"Pivot is to small! Stuck at word of length {}.\", word.len());\n            process::exit(1);\n        }\n        let mut line = String::new();\n        while line.len() + word.len() <= self.pivot {\n            line.push_str(&word);\n            line.push(Self::WORD_DELIMITER);\n            // Skip the peeked word\n            self.cover_text_iter.next();\n\n            if let Some(next_word) = self.cover_text_iter.peek() {\n                word = next_word;\n            } else {\n                return Some(line);\n            }\n        }\n        Some(line.trim_end().to_string())\n    }\n}\n\nimpl Context for PivotByLineContext {\n    fn get_current_text_mut(&mut self) -> Result<&mut String, ContextError> {\n        self.current_text\n            .as_mut()\n            .ok_or_else(|| ContextError::new(ContextErrorKind::NoTextLeft))\n    }\n\n    fn get_current_text(&self) -> Result<&String, ContextError> {\n        self.current_text\n            .as_ref()\n            .ok_or_else(|| ContextError::new(ContextErrorKind::NoTextLeft))\n    }\n\n    // Loads the line considering the pivot. Line length is smaller or equal the pivot value.\n    // This function does not preserve original whitespace. By default words are delimited by standard ASCII space (0x20). \n    //\n    // # Returns\n    // Result which is either the line or [ContextError] if anything fails. \n    fn load_text(&mut self) -> Result<&String, ContextError> {\n        self.current_text = self.construct_line_by_pivot();\n        self.current_text\n            .as_ref()\n            .ok_or_else(|| ContextError::new(ContextErrorKind::NoTextLeft))\n    }\n}\n\nimpl Context for PivotByRawLineContext {\n    fn get_current_text_mut(&mut self) -> Result<&mut String, ContextError> {\n        self.current_text\n            .as_mut()\n            .ok_or_else(|| ContextError::new(ContextErrorKind::NoTextLeft))\n    }\n\n    fn get_current_text(&self) -> Result<&String, ContextError> {\n        self.current_text\n            .as_ref()\n            .ok_or_else(|| ContextError::new(ContextErrorKind::NoTextLeft))\n    }\n\n    // Loads the raw line. By raw it means preserving the whitespace\n    //\n    // # Returns\n    // Result which is either the line or [ContextError] if anything fails. \n    fn load_text(&mut self) -> Result<&String, ContextError> {\n        self.current_text = self.cover_text_iter.next();\n        self.current_text\n            .as_ref()\n            .ok_or_else(|| ContextError::new(ContextErrorKind::NoTextLeft))\n    }\n}\n\n/// Enum determining the exact context error.\n#[derive(Debug)]\nenum ContextErrorKind {\n    NoTextLeft,\n}\n\n/// Error implementation for [Context]. Exact error message is determined by [ContextErrorKind].\n#[derive(Debug)]\npub struct ContextError {\n    kind: ContextErrorKind,\n}\n\nimpl ContextError {\n    fn new(kind: ContextErrorKind) -> Self {\n        ContextError { kind }\n    }\n}\n\nimpl fmt::Display for ContextError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self.kind {\n            ContextErrorKind::NoTextLeft => write!(f, \"No cover text left.\",),\n        }\n    }\n}\n\nimpl Error for ContextError {}\n","traces":[{"line":45,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":35,"coverable":49},{"path":["/","mnt","l","Projects","ptero-cli","src","decoder.rs"],"content":"use std::{convert::TryFrom, error::Error};\n\nuse log::{debug};\n\nuse crate::{binary::{Bit, BitVec}, context::{Context, ContextError}};\n\n// TODO: Provide DecoderError and mapping from ContextError\n/// Base trait for all data decoders.\n/// The generic type should contain data need by the decoder implementation.\npub trait Decoder<D> where D: Context {\n    /// Decodes bits from the cover text.\n    /// The access to the cover text is bound by the [Context].\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - context of the steganography method, can contain various needed info like pivot etc.\n    ///\n    /// # Returns\n    /// It returns `Result`, either decoded data as as vector of [Bits] or error.\n    ///\n    /// [Context]: crate::context::Context\n    /// [Bits]: crate::binary::Bit\n    fn partial_decode(&self, context: &D) -> Result<Vec<Bit>, ContextError>;\n\n    fn decode(&self, context: &mut D) -> Result<Vec<u8>, Box<dyn Error>> {\n        let mut secret = Vec::default();\n        debug!(\"Decoding secret from the text\");\n        while context.load_text().is_ok() {\n            let mut data = self.partial_decode(&context)?;\n            secret.append(&mut data);\n        }\n        debug!(\"Padding bits to byte size boundary\");\n        debug!(\"Unpadded secret data {:?}\", &secret);\n        while &secret.len() % 8 != 0 {\n            secret.push(Bit(0));\n        }\n    \n        debug!(\"Converting bits to bytes\");\n        let bit_vec: BitVec = secret.into();\n        let bytes: Vec<u8> = TryFrom::try_from(bit_vec)?;\n        Ok(bytes)\n    }\n}\n","traces":[{"line":25,"address":[4690501,4690416],"length":1,"stats":{"Line":3},"fn_name":"decode<ptero::method::complex::extended_line::ExtendedLineMethod,ptero::context::PivotByRawLineContext>"},{"line":26,"address":[4690442],"length":1,"stats":{"Line":3},"fn_name":null},{"line":27,"address":[4690649,4690516],"length":1,"stats":{"Line":6},"fn_name":null},{"line":28,"address":[4609345,4608901],"length":1,"stats":{"Line":6},"fn_name":null},{"line":29,"address":[4609029,4609212,4609305,4609257],"length":1,"stats":{"Line":4},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":14,"coverable":14},{"path":["/","mnt","l","Projects","ptero-cli","src","encoder.rs"],"content":"use std::{error::Error, fmt};\n\nuse log::{debug, trace};\n\nuse crate::{binary::Bit, context::Context};\n\n/// Possible results of data encoding\n#[derive(Debug, Clone)]\npub enum EncoderResult {\n    Success,\n    NoDataLeft,\n}\n\n/// Base trait for all data encoders.\n/// The generic type should contain data need by the encoder implementation.\npub trait Encoder<E>\nwhere\n    E: Context,\n{\n    /// Encodes bits provided by `data` iterator.\n    /// Every Encoder has Context which exposes access to cover text. See [Context] for more info.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - context of the steganography method, can contain various needed info like pivot etc.\n    /// * `data` - data iterator which return [Bit] with each iteration\n    ///\n    /// # Returns\n    /// It returns whether the encoding was successful. See [EncoderResult] and [EncodingError].\n    ///\n    /// [Context]: crate::context::Context\n    /// [EncoderResult]: EncoderResult\n    /// [EncodingError]: EncodingError\n    /// [Bit]: crate::binary::Bit\n    fn partial_encode(\n        &self,\n        context: &mut E,\n        data: &mut dyn Iterator<Item = Bit>,\n    ) -> Result<EncoderResult, Box<dyn Error>>;\n\n    fn encode(\n        &self,\n        context: &mut E,\n        data: &mut dyn Iterator<Item = Bit>,\n    ) -> Result<String, Box<dyn Error>> {\n        let mut stego_text = String::new();\n\n        let mut no_data_left = false;\n        while !no_data_left {\n            context.load_text()?;\n            trace!(\"Current line '{}'\", context.get_current_text()?);\n            if let EncoderResult::NoDataLeft = self.partial_encode(context, data)? {\n                debug!(\"No data left to encode, stopping\");\n                no_data_left = true;\n            }\n            let line = context.get_current_text()?;\n            stego_text.push_str(&format!(\"{}\\n\", &line));\n        }\n        // Append the rest of possible missing cover text\n        let mut appended_line_count = 0;\n        while let Ok(line) = context.load_text() {\n            appended_line_count += 1;\n            stego_text.push_str(&format!(\"{}\\n\", &line));\n        }\n        debug!(\"Appended the {} of left lines\", appended_line_count);\n\n        if !no_data_left {\n            debug!(\"Capacity exceeded by {} bits\", data.count());\n            Err(EncodingError::capacity_error().into())\n        } else {\n            Ok(stego_text)\n        }\n    }\n\n    /// This method provides the amount of bits encoded per line by the encoder.\n    fn rate(&self) -> u32;\n}\n\n/// Enum for data encoding errors types\n#[derive(Debug, Clone)]\npub enum EncodingErrorKind {\n    CapacityTooLow,\n    NoWordsLeft,\n}\n\n/// Represents encoding error. Concrete error if differentiated by the [EncodingErrorKind](EncodingErrorKind)\n#[derive(Debug, Clone)]\npub struct EncodingError {\n    kind: EncodingErrorKind,\n}\n\nimpl EncodingError {\n    /// Facade for creating [CapacityTooLow](EncodingErrorKind) error.\n    pub fn capacity_error() -> Self {\n        EncodingError {\n            kind: EncodingErrorKind::CapacityTooLow,\n        }\n    }\n    /// Facade for creating [NoWordsLeft](EncodingErrorKind) error.\n    pub fn no_words_error() -> Self {\n        EncodingError {\n            kind: EncodingErrorKind::NoWordsLeft,\n        }\n    }\n}\n\nimpl fmt::Display for EncodingError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match &self.kind {\n            EncodingErrorKind::CapacityTooLow => write!(f, \"Exceeded cover text capacity\"),\n            EncodingErrorKind::NoWordsLeft => write!(\n                f,\n                \"No extra words found in cover text when tried to encode a bit\"\n            ),\n        }\n    }\n}\n\nimpl Error for EncodingError {}\n","traces":[{"line":41,"address":[4686656,4686780],"length":1,"stats":{"Line":3},"fn_name":"encode<ptero::method::complex::extended_line::ExtendedLineMethod,ptero::context::PivotByLineContext>"},{"line":46,"address":[4709994],"length":1,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[4710091],"length":1,"stats":{"Line":3},"fn_name":null},{"line":49,"address":[4570469,4568515],"length":1,"stats":{"Line":5},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":18,"coverable":27},{"path":["/","mnt","l","Projects","ptero-cli","src","lib.rs"],"content":"//! # ptero\n//!\n//! `ptero` is a crate with utilities for the `ptero_cli` frontend\n\n/// Utils for binary data manipulation\npub mod binary;\n\n/// Provides functions for manipulation text e.g. word iterator\npub mod text;\n\n/// Contains secret data encoders both simple and complex ones.\npub mod encoder;\n\n/// Contains stegotext decoders.\npub mod decoder;\n\n/// Context containing all needed data (e.g. access to cover text) for the steganography methods.\npub mod context;\n\n/// Module containing all the available methods for text steganography. \npub mod method;\n\n/// Logger utilities.\npub mod log;\n\npub mod cli {\n    pub mod capacity;\n    pub mod decoder;\n    pub mod encoder;\n    pub mod writer;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","mnt","l","Projects","ptero-cli","src","log.rs"],"content":"use fern::{\n    colors::{Color, ColoredLevelConfig},\n    Dispatch,\n};\nuse log::{Level, LevelFilter};\n\n/// Converts verbosity number to [LevelFilter](log::LevelFilter) enum.\n/// Used for configuring the logging level.\n/// # Arguments\n///\n/// * `verbosity` - verbosity level described by number `u8`\n///\n/// # Examples\n/// ## Converts verbosity number\n/// ```\n/// use ptero::log::verbosity_to_level_filter;\n/// use log::{LevelFilter};\n///\n/// assert_eq!(verbosity_to_level_filter(0), LevelFilter::Info);\n/// assert_eq!(verbosity_to_level_filter(1), LevelFilter::Debug);\n/// assert_eq!(verbosity_to_level_filter(2), LevelFilter::Trace);\n/// ```\n/// ## Unrecognized verbosity defaults to trace\n/// ```\n/// use ptero::log::verbosity_to_level_filter;\n/// use log::{LevelFilter};\n///\n/// assert_eq!(verbosity_to_level_filter(3), LevelFilter::Trace);\n/// assert_eq!(verbosity_to_level_filter(100), LevelFilter::Trace);\n/// assert_eq!(verbosity_to_level_filter(255), LevelFilter::Trace);\n/// ```\npub fn verbosity_to_level_filter(verbosity: u8) -> LevelFilter {\n    match verbosity {\n        0 => LevelFilter::Info,\n        1 => LevelFilter::Debug,\n        _ => LevelFilter::Trace,\n    }\n}\n\n/// Returns pre-configured [ColoredLevelConfig](fern::colors::ColoredLevelConfig) used to color\n/// logging level.\nfn get_logging_colors() -> ColoredLevelConfig {\n    ColoredLevelConfig::new()\n        .error(Color::Red)\n        .warn(Color::BrightYellow)\n        .debug(Color::Magenta)\n        .trace(Color::BrightBlack)\n}\n\n/// Returns text which will be shown before the message. Used only in stdout formatter.\nfn get_level_text(level: &Level) -> &str {\n    match level {\n        Level::Error => \"ERROR\",\n        Level::Warn => \" WARN\",\n        Level::Info => \"     \",\n        Level::Debug => \"DEBUG\",\n        Level::Trace => \"TRACE\",\n    }\n}\n\n/// Returns pre-configured stdout logger.\n/// It only shows info relevant to user like message and logging level.\n/// Uses coloring unlike file logger.\n///\n/// # Arguments\n/// * `log_level` - level filter which is used to restrict amount of logs to user\npub fn get_stdout_logger(log_level: LevelFilter) -> Dispatch {\n    let colors = get_logging_colors();\n\n    fern::Dispatch::new()\n        .format(move |out, message, record| {\n            out.finish(format_args!(\n                \"{color_line}{level_txt}\\x1B[0m  {message}\",\n                level_txt = get_level_text(&record.level()),\n                color_line =\n                    format_args!(\"\\x1B[{}m\", colors.get_color(&record.level()).to_fg_str()),\n                message = message,\n            ));\n        })\n        .level(log_level)\n        .chain(std::io::stderr())\n}\n\n/// Returns pre-configured file logger.\n/// This logger does not used coloring and adds additional info like date time or module path.\n/// It doesn't restrict logging - saves everything beginning from `TRACE` level.\n///\n/// # Arguments\n/// * `log_path` - path to the log file which will be used to store logs\npub fn get_file_logger(log_path: &str) -> Dispatch {\n    fern::Dispatch::new()\n        .format(move |out, message, record| {\n            out.finish(format_args!(\n                \"{}[{}][{}] - {}\",\n                chrono::Local::now().format(\"[%Y-%m-%d][%H:%M:%S]\"),\n                &record.target(),\n                &record.level(),\n                message,\n            ));\n        })\n        .level(LevelFilter::Trace)\n        .chain(fern::log_file(&log_path).unwrap())\n}\n","traces":[{"line":32,"address":[4650192],"length":1,"stats":{"Line":0},"fn_name":"verbosity_to_level_filter"},{"line":33,"address":[4434568,4434579],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[4650234,4650201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[4650245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[4650223],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[4650272],"length":1,"stats":{"Line":0},"fn_name":"get_logging_colors"},{"line":43,"address":[4650276,4650316,4650388,4650460,4650532],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[4650311],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[4650383],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[4650455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[4650527],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[4650640],"length":1,"stats":{"Line":0},"fn_name":"get_level_text"},{"line":52,"address":[4650772,4650726,4650749,4650701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[4650649,4650712],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[4650735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[4650758],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[4650781],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[4650687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[4650816,4650906],"length":1,"stats":{"Line":0},"fn_name":"get_stdout_logger"},{"line":68,"address":[4650834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[4651067,4650956,4650921],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[4650934],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[4664015,4664335],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[4664055],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[4664120],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[4651044],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[4651100,4651052,4651121],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[4651240,4651184],"length":1,"stats":{"Line":0},"fn_name":"get_file_logger"},{"line":91,"address":[4651289,4651255,4651377,4651204],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[4664704,4664825],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":93,"address":[4665038,4664735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[4664847,4664758],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[4664885],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[4664964,4665006],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[4651277,4651315],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[4651323,4651410,4651431],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":36},{"path":["/","mnt","l","Projects","ptero-cli","src","method","complex","eluv.rs"],"content":"//! # Description\n//!\n//! This method implements the Extended Line Unicode Variant (ELUV) steganography algorithm. It consist of three\n//! simpler methods:\n//! * [RandomWhitespaceMethod](crate::method::random_whitespace::RandomWhitespaceMethod),\n//! * [LineExtendMethod](crate::method::line_extend::LineExtendMethod),\n//! * [TrailingUnicodeMethod](crate::method::trailing_unicode::TrailingUnicodeMethod).\n//!\n//! For more info read docs on each one of the above encoders.\n\nuse crate::{\n    context::{PivotByLineContext, PivotByRawLineContext},\n    impl_complex_decoder, impl_complex_encoder,\n    method::{line_extend, random_whitespace, trailing_unicode, Method},\n};\n\n/// Structure representing the ELUV algorithm.\n/// Contains the vector of used methods. Uses macros to implement the required traits.\npub struct ELUVMethod {\n    methods: Vec<Box<dyn Method<PivotByLineContext, PivotByRawLineContext>>>,\n}\n\nimpl ELUVMethod {\n    fn new() -> Self {\n        ELUVMethod {\n            methods: vec![\n                Box::new(random_whitespace::RandomWhitespaceMethod::default()),\n                Box::new(line_extend::LineExtendMethod::default()),\n                Box::new(trailing_unicode::TrailingUnicodeMethod::default()),\n            ],\n        }\n    }\n}\n\nimpl Default for ELUVMethod {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl_complex_encoder!(ELUVMethod, PivotByLineContext);\nimpl_complex_decoder!(ELUVMethod, PivotByRawLineContext);\n\nimpl Method<PivotByLineContext, PivotByRawLineContext> for ELUVMethod {}\n\n#[allow(unused_imports)]\nmod test {\n    use std::error::Error;\n\n    use crate::{binary::BitIterator, cli::encoder::EncodeSubCommand, context::{PivotByLineContext, PivotByRawLineContext}, decoder::Decoder, encoder::Encoder};\n\n    use super::ELUVMethod;\n\n    #[test]\n    fn encodes_text_data() -> Result<(), Box<dyn Error>> {\n        let cover_input = \"a b c \".repeat(5);\n        let data_input = \"abc\";\n        let pivot: usize = 3;\n\n        let mut data_iterator = BitIterator::new(&data_input.as_bytes());\n        let method = ELUVMethod::default();\n        let mut context = PivotByLineContext::new(&cover_input, pivot);\n        let stego_text = method.encode(&mut context, &mut data_iterator)?;\n\n        assert_eq!(\n            &stego_text,\n            \"a b c\\u{2028}\\na  b\\u{2062}\\nc  a\\u{200b}\\nb c a \\nb c\\na b\\nc \\n\"\n        );\n        Ok(())\n    }\n\n    #[test]\n    fn encodes_binary_data() -> Result<(), Box<dyn Error>> {\n        let cover_input = \"a b c \".repeat(6);\n        let data_input: Vec<u8> = vec![0b11101010, 0b10000011, 0b01011110];\n        let pivot: usize = 3;\n\n        let mut data_iterator = BitIterator::new(&data_input);\n        let method = ELUVMethod::default();\n        let mut context = PivotByLineContext::new(&cover_input, pivot);\n        let stego_text = method.encode(&mut context, &mut data_iterator)?;\n\n        assert_eq!(\n            &stego_text,\n            \"a  b c\\u{205f}\\na b c\\na  b c\\u{200a}\\na  b c\\na b\\nc a\\nb c \\n\"\n        );\n        Ok(())\n    }\n\n    #[test]\n    fn decodes_binary_data() ->  Result<(), Box<dyn Error>> {\n        let stego_text = \"a  bc\\na bcd \\na  b d\\u{205f}\\n\";\n        let pivot: usize = 4;\n\n        let method = ELUVMethod::default();\n        let mut context = PivotByRawLineContext::new(&stego_text, pivot);\n        let secret_data = method.decode(&mut context)?;\n\n        assert_eq!(&secret_data, &[0b10_00000_0, 0b1_00001_11, 0b10101_000]);\n        Ok(())\n    }\n\n    #[test]\n    fn decodes_zeroes_if_no_data_encoded() ->  Result<(), Box<dyn Error>> {\n        let stego_text = \"a\\n\".repeat(5);\n        let pivot: usize = 4;\n\n        let method = ELUVMethod::default();\n        let mut context = PivotByRawLineContext::new(&stego_text, pivot);\n        let secret_data = method.decode(&mut context)?;\n\n        assert_eq!(&secret_data, &[0, 0, 0, 0, 0]);\n        Ok(())\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[4234288,4234297],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":56,"address":[4314686],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[4314730],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[4314757],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[4314849],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[4314931],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[4314946],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[4315104,4315299,4315020,4315390,4315477],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[4315502,4315214,4315547],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[4315198],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[4315508],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[4234336,4234345],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":74,"address":[4316030],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[4316085],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[4316154],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[4316166],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[4316256],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[4316271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[4316624,4316345,4316429,4316821,4316715],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[4316894,4316849,4316539],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[4316523],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[4316855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[4234384,4234393],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":92,"address":[4317422],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[4317442],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[4317454],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[4317484],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[4317887,4317604,4317955,4317544,4317582,4317799],"length":1,"stats":{"Line":3},"fn_name":null},{"line":99,"address":[4317980,4318022,4317698],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[4317986],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[4234441,4234432],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":105,"address":[4318462],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[4318506],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[4318526],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[4318541,4318609],"length":1,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[4318986,4318655,4318895,4318700,4319073],"length":1,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[4319143,4318794,4319098],"length":1,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[4319104],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":42,"coverable":42},{"path":["/","mnt","l","Projects","ptero-cli","src","method","complex","extended_line.rs"],"content":"//! # Description\n//!\n//! This method implements the *Extended Line* steganography algorithm. It consist of three\n//! simpler methods:\n//! * [RandomWhitespaceMethod](crate::method::random_whitespace::RandomWhitespaceMethod),\n//! * [LineExtendMethod](crate::method::line_extend::LineExtendMethod),\n//! * [TrailingWhitespaceMethod](crate::trailing_whitespace::TrailingWhitespaceMethod).\n//!\n//! For more info read docs on each one of the above encoders.\n\nuse crate::{\n    context::{PivotByLineContext, PivotByRawLineContext},\n    impl_complex_decoder, impl_complex_encoder,\n    method::{line_extend, random_whitespace, trailing_whitespace, Method},\n};\n\n/// Structure representing the Extended Line algorithm.\n/// Contains the vector of used methods. Uses macros to implement the required traits.\npub struct ExtendedLineMethod {\n    methods: Vec<Box<dyn Method<PivotByLineContext, PivotByRawLineContext>>>,\n}\n\nimpl ExtendedLineMethod {\n    pub fn new() -> Self {\n        ExtendedLineMethod {\n            methods: vec![\n                Box::new(random_whitespace::RandomWhitespaceMethod::default()),\n                Box::new(line_extend::LineExtendMethod::new()),\n                Box::new(trailing_whitespace::TrailingWhitespaceMethod::default()),\n            ],\n        }\n    }\n}\n\nimpl Default for ExtendedLineMethod {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl_complex_encoder!(ExtendedLineMethod, PivotByLineContext);\nimpl_complex_decoder!(ExtendedLineMethod, PivotByRawLineContext);\n\nimpl Method<PivotByLineContext, PivotByRawLineContext> for ExtendedLineMethod {}\n\n#[allow(unused_imports)]\nmod test {\n    use std::error::Error;\n\n    use crate::{\n        binary::BitIterator,\n        context::{PivotByLineContext, PivotByRawLineContext},\n        decoder::Decoder,\n        encoder::Encoder,\n    };\n\n    use super::ExtendedLineMethod;\n\n    #[test]\n    fn encodes_text_data() -> Result<(), Box<dyn Error>> {\n        let cover_input = \"a b c\".repeat(5);\n        let data_input = \"a\";\n        let pivot: usize = 4;\n\n        let mut data_iterator = BitIterator::new(&data_input.as_bytes());\n        let method = ExtendedLineMethod::default();\n        let mut context = PivotByLineContext::new(&cover_input, pivot);\n        let stego_text = method.encode(&mut context, &mut data_iterator)?;\n\n        assert_eq!(&stego_text, \"a b ca \\nb ca\\nb ca b\\nca b\\nc \\n\");\n        Ok(())\n    }\n\n    #[test]\n    fn encodes_binary_data() -> Result<(), Box<dyn Error>> {\n        let cover_input = \"a b c \".repeat(5);\n        let data_input: Vec<u8> = vec![0b11111111];\n        let pivot: usize = 3;\n\n        let mut data_iterator = BitIterator::new(&data_input);\n        let method = ExtendedLineMethod::default();\n        let mut context = PivotByLineContext::new(&cover_input, pivot);\n        let stego_text = method.encode(&mut context, &mut data_iterator)?;\n\n        assert_eq!(&stego_text, \"a  b c \\na  b c \\na  b c\\na b\\nc a\\nb c \\n\");\n        Ok(())\n    }\n\n    #[test]\n    fn decodes_binary_data() -> Result<(), Box<dyn Error>> {\n        let stego_text = \"a  bc\\na bcd\\na  b d \\n\";\n        let pivot: usize = 4;\n\n        let method = ExtendedLineMethod::default();\n        let mut context = PivotByRawLineContext::new(&stego_text, pivot);\n        let secret_data = method.decode(&mut context)?;\n\n        assert_eq!(&secret_data, &[0b100_010_11, 0b100_000_00]);\n        Ok(())\n    }\n\n    #[test]\n    fn decodes_zeroes_if_no_data_encoded() -> Result<(), Box<dyn Error>> {\n        let stego_text = \"a\\n\".repeat(5);\n        let pivot: usize = 4;\n\n        let method = ExtendedLineMethod::default();\n        let mut context = PivotByRawLineContext::new(&stego_text, pivot);\n        let secret_data = method.decode(&mut context)?;\n\n        assert_eq!(&secret_data, &[0, 0]);\n        Ok(())\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[4350272,4350281],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":61,"address":[4352430],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[4352475],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[4352502],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[4352594],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[4352676],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[4352691],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[4353222,4353044,4352765,4352849,4353135],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[4352943,4353247,4353292],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[4353253],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[4350329,4350320],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":76,"address":[4353774],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[4353823],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[4353887],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[4353899],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[4353989],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[4354004],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[4354162,4354357,4354448,4354078,4354554],"length":1,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[4354582,4354627,4354256],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[4354588],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[4350368,4350377],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":91,"address":[4355150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[4355170],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[4355182],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[4355212],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[4355272,4355527,4355332,4355615,4355683,4355310],"length":1,"stats":{"Line":3},"fn_name":null},{"line":98,"address":[4355708,4355750,4355426],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[4355714],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[4350416,4350425],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":104,"address":[4356190],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[4356234],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[4356254],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[4356269,4356337],"length":1,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[4356383,4356623,4356801,4356428,4356714],"length":1,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[4356522,4356871,4356826],"length":1,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[4356832],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":40,"coverable":40},{"path":["/","mnt","l","Projects","ptero-cli","src","method","complex.rs"],"content":"pub mod eluv;\npub mod extended_line;\n\n/// Macro for implementing the [Encoder](crate::encoder::Encoder) trait for\n/// complex methods. It assumes that method is only composed by other methods.\n///\n/// Requires the method to have `methods` field being vector containing type [Encoder](crate::encoder::Encoder).\n#[macro_export]\nmacro_rules! impl_complex_encoder {\n    ($t:ident, $c:ident) => {\n        impl crate::encoder::Encoder<$c> for $t {\n            fn partial_encode(\n                &self,\n                context: &mut $c,\n                data: &mut dyn Iterator<Item = crate::binary::Bit>,\n            ) -> Result<crate::encoder::EncoderResult, Box<dyn std::error::Error>> {\n                let mut is_data_still_available = crate::encoder::EncoderResult::Success;\n                for encoder in &self.methods {\n                    if let crate::encoder::EncoderResult::NoDataLeft =\n                        encoder.partial_encode(context, data)?\n                    {\n                        is_data_still_available = crate::encoder::EncoderResult::NoDataLeft;\n                        break;\n                    }\n                }\n                Ok(is_data_still_available)\n            }\n\n            fn rate(&self) -> u32 {\n                self.methods\n                    .iter()\n                    .fold(0, |acc, encoder| acc + encoder.rate())\n            }\n        }\n    };\n}\n\n/// Macro for implementing the [Decoder](crate::decoder::Decoder) trait for\n/// complex methods. It assumes that method is only composed by other methods.\n///\n/// Requires the method to have `methods` field being vector containing type [Decoder](crate::decoder::Decoder).\n#[macro_export]\nmacro_rules! impl_complex_decoder {\n    ($t:ident, $c:ident) => {\n        impl crate::decoder::Decoder<$c> for $t {\n            fn partial_decode(\n                &self,\n                context: &$c,\n            ) -> Result<Vec<crate::binary::Bit>, crate::context::ContextError> {\n                let mut secret_data = Vec::default();\n                for decoder in &self.methods {\n                    let mut result = decoder.partial_decode(context)?;\n                    secret_data.append(&mut result);\n                }\n                Ok(secret_data)\n            }\n        }\n    };\n}\n","traces":[{"line":12,"address":[4561762,4561488],"length":1,"stats":{"Line":3},"fn_name":"partial_encode"},{"line":17,"address":[4331658],"length":1,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[4349172,4349536],"length":1,"stats":{"Line":5},"fn_name":null},{"line":19,"address":[4349428],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[4349300,4349527,4349447,4349406,4349357],"length":1,"stats":{"Line":7},"fn_name":null},{"line":22,"address":[4332037],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[4561941],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[4561705],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[4600720],"length":1,"stats":{"Line":0},"fn_name":"rate"},{"line":30,"address":[4561977],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[4692992,4693010],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":46,"address":[4600816,4600878],"length":1,"stats":{"Line":4},"fn_name":"partial_decode"},{"line":50,"address":[4562090],"length":1,"stats":{"Line":4},"fn_name":null},{"line":51,"address":[4562624,4562202,4562141,4562339],"length":1,"stats":{"Line":12},"fn_name":null},{"line":52,"address":[4562370,4562537,4562590,4562563],"length":1,"stats":{"Line":4},"fn_name":null},{"line":53,"address":[4562516],"length":1,"stats":{"Line":3},"fn_name":null},{"line":55,"address":[4562255],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":14,"coverable":17},{"path":["/","mnt","l","Projects","ptero-cli","src","method","line_extend.rs"],"content":"//! # Description\n//!\n//! This encoder extends line with extra word (to be greater than pivot) to encode bit.\n//! If the line length is greater than the pivot the bit 1 is encoded, otherwise 0.\n//!  \n//! For more info about pivot see [LineByPivotIterator](../../text/struct.LineByPivotIterator.html).\n//!\n//! # Behavior\n//!\n//! This encoder can return [EncodingError](../struct.EncodingError.html) when no extra words are found\n//! and the bit 1 occurs.\nuse std::error::Error;\n\nuse log::{trace};\nuse regex::Regex;\n\nuse crate::{binary::Bit, context::{Context, ContextError, PivotByLineContext, PivotByRawLineContext}, decoder::Decoder, encoder::{Encoder, EncoderResult, EncodingError}};\n\nuse super::Method;\n\n/// Character used as the word delimiter.\npub const ASCII_DELIMITER: char = ' ';\n\n/// Unit structure representing the line extension method.\n///\n/// Accepts only following contexts: [PivotByLineContext](crate::context::PivotByLineContext) for [Encoder](crate::encoder::Encoder) trait and\n// [PivotByRawLineContext](crate::context::PivotByRawLineContext) for [Decoder](crate::decoder::Decoder) trait.\n// *Decoder needs to consume raw lines to be able to decode information using pivot.*\npub struct LineExtendMethod;\n\nimpl LineExtendMethod {\n    pub fn new() -> Self {\n        LineExtendMethod {}\n    }\n}\n\nimpl Default for LineExtendMethod {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl Encoder<PivotByLineContext> for LineExtendMethod {\n    fn partial_encode(\n        &self,\n        context: &mut PivotByLineContext,\n        data: &mut dyn Iterator<Item = Bit>,\n    ) -> Result<EncoderResult, Box<dyn Error>> {\n        Ok(match data.next() {\n            Some(Bit(1)) => {\n                // TODO: Provide mapping for ContextError -> EncodingError\n                let word = context\n                    .next_word()\n                    .ok_or_else(EncodingError::no_words_error)?;\n                trace!(\"Extending line with '{}'\", &word);\n                let text = context.get_current_text_mut()?;\n                text.push(ASCII_DELIMITER);\n                text.push_str(word.as_str());\n                EncoderResult::Success\n            }\n            None => EncoderResult::NoDataLeft,\n            _ => EncoderResult::Success,\n        })\n    }\n    fn rate(&self) -> u32 {\n        1\n    }\n}\n\nimpl Decoder<PivotByRawLineContext> for LineExtendMethod {\n    fn partial_decode(&self, context: &PivotByRawLineContext) -> Result<Vec<Bit>, ContextError> {\n        let pattern = Regex::new(r\"\\s+\").unwrap();\n        let cleaned_line = pattern.replace_all(context.get_current_text()?, \" \");\n        let bit = if cleaned_line.trim_end().len() > context.get_pivot() {\n            trace!(\"Line is extended over the {} length\", context.get_pivot());\n            Bit(1)\n        } else {\n            Bit(0)\n        };\n        Ok(vec![bit])\n    }\n}\n\nimpl Method<PivotByLineContext, PivotByRawLineContext> for LineExtendMethod {}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[4367472],"length":1,"stats":{"Line":3},"fn_name":"default"},{"line":39,"address":[4367473],"length":1,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[4661616,4661707],"length":1,"stats":{"Line":1},"fn_name":"partial_encode"},{"line":49,"address":[4661787,4662726,4662716,4661658],"length":1,"stats":{"Line":4},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[4661987,4661792,4661882],"length":1,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[4662718],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[4661779],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[4662816,4662903],"length":1,"stats":{"Line":2},"fn_name":"partial_decode"},{"line":72,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":20,"coverable":24},{"path":["/","mnt","l","Projects","ptero-cli","src","method","random_whitespace.rs"],"content":"//! # Description\n//!\n//! This method puts [ASCII_WHITESPACE](crate::method::random_whitespace::ASCII_WHITESPACE) between randomly selected two words.\n//! If the duplicate whitespace is present the bit 1 is encoded, otherwise 0.\nuse std::error::Error;\n\nuse crate::{\n    binary::Bit,\n    context::{Context, ContextError},\n    decoder::Decoder,\n    encoder::{Encoder, EncoderResult},\n};\n\nuse log::{trace};\nuse rand::{thread_rng, Rng};\n\n/// Character used as the random whitespace in the method.\npub const ASCII_WHITESPACE: char = ' ';\n\nuse super::Method;\n\n/// Unit structure representing the random whitespace method.\n/// Implements both [Encoder](crate::encoder::Encoder) and [Decoder](crate::decoder::Decoder) traits.\n///\n/// Accepts any [Context](crate::context::Context).\npub struct RandomWhitespaceMethod;\n\nimpl Default for RandomWhitespaceMethod {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl RandomWhitespaceMethod {\n    pub fn new() -> Self {\n        RandomWhitespaceMethod {}\n    }\n}\n\nimpl<T> Encoder<T> for RandomWhitespaceMethod\nwhere\n    T: Context,\n{\n    fn partial_encode(\n        &self,\n        context: &mut T,\n        data: &mut dyn Iterator<Item = Bit>,\n    ) -> Result<EncoderResult, Box<dyn Error>> {\n        Ok(match data.next() {\n            Some(Bit(1)) => {\n                let mut rng = thread_rng();\n                let text = context.get_current_text_mut()?;\n                let position_determinant = rng.gen_range(0, &text.len());\n                let mut position = text.find(' ').unwrap_or_else(|| text.len());\n                for (index, character) in text.char_indices() {\n                    if index > position_determinant {\n                        break;\n                    }\n                    if character.is_whitespace() {\n                        position = index;\n                    }\n                }\n                trace!(\"Putting space at position {}\", position);\n                text.insert_str(position, &String::from(ASCII_WHITESPACE));\n                EncoderResult::Success\n            }\n            None => EncoderResult::NoDataLeft,\n            _ => EncoderResult::Success,\n        })\n    }\n    fn rate(&self) -> u32 {\n        1\n    }\n}\n\nimpl<D> Decoder<D> for RandomWhitespaceMethod\nwhere\n    D: Context,\n{\n    fn partial_decode(&self, context: &D) -> Result<Vec<Bit>, ContextError> {\n        let mut seen_whitespace = false;\n        for character in context.get_current_text()?.chars() {\n            let is_whitespace = character == ASCII_WHITESPACE;\n            if seen_whitespace && is_whitespace {\n                trace!(\"Found two consecutive '{}' between words\", ASCII_WHITESPACE,);\n                return Ok(vec![Bit(1)]);\n            }\n            seen_whitespace = is_whitespace;\n        }\n        Ok(vec![Bit(0)])\n    }\n}\n\nimpl<E, D> Method<E, D> for RandomWhitespaceMethod\nwhere\n    E: Context,\n    D: Context,\n{\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":30,"address":[4723185],"length":1,"stats":{"Line":4},"fn_name":null},{"line":35,"address":[4723200],"length":1,"stats":{"Line":5},"fn_name":"new"},{"line":44,"address":[4574795,4574704],"length":1,"stats":{"Line":2},"fn_name":"partial_encode<ptero::context::PivotByLineContext>"},{"line":49,"address":[4576031,4574746,4574875,4576021],"length":1,"stats":{"Line":5},"fn_name":null},{"line":50,"address":[4574810],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[4574880],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[4574902,4575076,4575010],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[4575464],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[4575539],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[4575528,4575545],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[4575558],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[4575635,4575571,4575487],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[4575881],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[4576013],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":29,"coverable":31},{"path":["/","mnt","l","Projects","ptero-cli","src","method","trailing_unicode.rs"],"content":"//! # Description\n//!\n//! This method encodes n-bits using available set of unicode whitespace. Larger sets provide better capacity\n//! but might not work for every channel - it depends which characters get sanitized or are actually used.\n//!\n//! The whitespace are added at the end of the line as some of them are actually visible and might\n//! lower the imperceptibility of this method.\n//!\n//! The amount of bits encoded by this implementation depends on used Unicode character set.\n//! It it at most 5 bits per line with [FULL_UNICODE_CHARACTER_SET].\n//!\n//! Encoder does not inform if there is not data left!\nuse std::error::Error;\n\nuse crate::{\n    binary::BitVec,\n    context::{Context, ContextError},\n    decoder::Decoder,\n    encoder::{Encoder, EncoderResult},\n};\nuse log::trace;\n\nuse crate::binary::Bit;\n\nuse super::Method;\n\n/// This trait is used for reading unicode set data.\n///\n/// New sets should implement `get_set` which provides the array with\n/// unicode characters used by the method.\npub trait UnicodeSet {\n    /// # Returns\n    /// Returns the array of characters representing the Unicode characters that should be used by the method.\n    /// The size of the array should be a power od 2. This is a requirement to be able to encode integer amount of bits.\n    fn get_set(&self) -> &[char];\n\n    fn size(&self) -> usize {\n        self.get_set().len()\n    }\n\n    /// # Returns\n    /// Returns the capacity of the set.\n    /// By capacity it means the amount of bits that can possibly be encoded using this set.\n    fn capacity(&self) -> usize {\n        let amount_of_bits = std::mem::size_of::<usize>() * 8;\n        amount_of_bits - self.size().leading_zeros() as usize\n    }\n\n    fn get_character(&self, index: u32) -> Option<&char> {\n        let index = index as usize;\n        if index == 0 {\n            None\n        } else if index > self.size() {\n            panic!(\"Too large number for given unicode set - cannot encode this amount of bits\");\n        } else {\n            self.get_set().get(index - 1)\n        }\n    }\n\n    /// # Returns\n    /// Number represented by the character.\n    /// The number is the bit representation of the character - or in other words the index.\n    /// If the character is not recognized it returns 0 by default.\n    fn character_to_bits(&self, chr: &char) -> u32 {\n        if let Some(pos) = self.get_set().iter().position(|x| x == chr) {\n            (pos + 1) as u32\n        } else {\n            0\n        }\n    }\n}\n\n/// Full set of used Unicode whitespace and invisible special chars - from different width spaces\n/// to formatting chars and zero-width spaces.\npub const FULL_UNICODE_CHARACTER_SET: [char; 31] = [\n    '\\u{0020}', '\\u{2000}', '\\u{2001}', '\\u{2002}', '\\u{2003}', '\\u{2004}', '\\u{2005}', '\\u{2006}',\n    '\\u{2007}', '\\u{2009}', '\\u{200A}', '\\u{200B}', '\\u{200C}', '\\u{200D}', '\\u{200E}', '\\u{2028}',\n    '\\u{202A}', '\\u{202C}', '\\u{202D}', '\\u{202F}', '\\u{205F}', '\\u{2060}', '\\u{2061}', '\\u{2062}',\n    '\\u{2063}', '\\u{2064}', '\\u{2066}', '\\u{2068}', '\\u{2069}', '\\u{3000}', '\\u{FEFF}',\n];\n/// Unit struct representing the [FULL_UNICODE_CHARACTER_SET].\npub struct FullUnicodeSet;\n\nimpl UnicodeSet for FullUnicodeSet {\n    fn get_set(&self) -> &[char] {\n        &FULL_UNICODE_CHARACTER_SET\n    }\n}\n\n/// Trailing unicode encoder for generic Unicode character sets.\n/// It uses the [UnicodeSet] to get the character given the n-bits\n/// (where n is the binary logarithm of the set size).\n///\n/// Accepts any [Context](crate::context::Context).\npub struct TrailingUnicodeMethod<T: UnicodeSet> {\n    unicode_set: T,\n}\n\nimpl Default for TrailingUnicodeMethod<FullUnicodeSet> {\n    fn default() -> Self {\n        Self::new(FullUnicodeSet {})\n    }\n}\n\nimpl<T> TrailingUnicodeMethod<T>\nwhere\n    T: UnicodeSet,\n{\n    pub fn new(unicode_set: T) -> Self {\n        TrailingUnicodeMethod { unicode_set }\n    }\n}\n\nimpl<T, E> Encoder<E> for TrailingUnicodeMethod<T>\nwhere\n    T: UnicodeSet,\n    E: Context,\n{\n    fn partial_encode(\n        &self,\n        context: &mut E,\n        data: &mut dyn Iterator<Item = Bit>,\n    ) -> Result<EncoderResult, Box<dyn Error>> {\n        let set_capacity = self.unicode_set.capacity();\n        let next_n_bits: BitVec = data.take(set_capacity).collect::<Vec<Bit>>().into();\n        let number: u32 = next_n_bits.into();\n        trace!(\n            \"Took {} bits and assembled a number: {}\",\n            set_capacity,\n            number\n        );\n        if let Some(character) = self.unicode_set.get_character(number) {\n            trace!(\n                \"Putting unicode character {:?} at the end of the line\",\n                character\n            );\n            context.get_current_text_mut()?.push(*character);\n        }\n        // Take doesn't advance the iterator so we have to do it by ourselves\n        // for _ in 0..set_capacity {\n        //     data.next();\n        // }\n        Ok(EncoderResult::Success)\n    }\n\n    fn rate(&self) -> u32 {\n        self.unicode_set.capacity() as u32\n    }\n}\n\nimpl<T, D> Decoder<D> for TrailingUnicodeMethod<T>\nwhere\n    T: UnicodeSet,\n    D: Context,\n{\n    fn partial_decode(&self, context: &D) -> Result<Vec<Bit>, ContextError> {\n        if let Some(character) = context.get_current_text()?.chars().last() {\n            if character.is_whitespace() {\n                trace!(\"Found '{:?}' at the end of the line\", character);\n                let data: Vec<Bit> =\n                    BitVec::from(self.unicode_set.character_to_bits(&character)).into();\n                let data_length = data.len();\n                // Skip the unnecessary zeroes from the beginning\n                let data_iter = data.into_iter().skip(data_length - self.unicode_set.capacity());\n                let decoded_data = data_iter.collect::<Vec<Bit>>();\n                return Ok(decoded_data);\n            }\n        }\n        let zero_bits = vec![0]\n            .repeat(self.unicode_set.capacity())\n            .iter()\n            .map(|v| Bit(*v))\n            .collect::<Vec<Bit>>();\n        Ok(zero_bits)\n    }\n}\n\nimpl<T, E, D> Method<E, D> for TrailingUnicodeMethod<T>\nwhere\n    T: UnicodeSet,\n    E: Context,\n    D: Context,\n{\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":40,"coverable":49},{"path":["/","mnt","l","Projects","ptero-cli","src","method","trailing_whitespace.rs"],"content":"//! # Description\n//!\n//! This method uses the trailing [ASCII_WHITESPACE] to encode bits.\n//! If the whitespace is present the bit 1 is encoded, otherwise 0.\n//!\n//! This method provides both encoding and decoding algorithm.\n\nuse std::error::Error;\n\nuse log::{trace};\n\nuse crate::{binary::{Bit}, context::{Context, ContextError}, decoder::Decoder, encoder::{Encoder, EncoderResult}};\n\n/// Character used as the trailing whitespace in the method.\npub const ASCII_WHITESPACE: char = ' ';\n\nuse super::Method;\n// Unit structure used to define the method.\n// Implements both [Encoder](crate::encoder::Encode) and [Decoder](crate::decoder::Decoder) traits.\n// Accepts any [Context](crate::context::Context).\npub struct TrailingWhitespaceMethod;\n\nimpl Default for TrailingWhitespaceMethod {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl TrailingWhitespaceMethod {\n    pub fn new() -> Self {\n        TrailingWhitespaceMethod {}\n    }\n}\n\nimpl<E> Encoder<E> for TrailingWhitespaceMethod\nwhere\n    E: Context,\n{\n    fn partial_encode(\n        &self,\n        context: &mut E,\n        data: &mut dyn Iterator<Item = Bit>,\n    ) -> Result<EncoderResult, Box<dyn Error>> {\n        Ok(match data.next() {\n            Some(Bit(1)) => {\n                trace!(\"Putting whitespace at the end of the line\");\n                context.get_current_text_mut()?.push(ASCII_WHITESPACE);\n                EncoderResult::Success\n            }\n            None => EncoderResult::NoDataLeft,\n            _ => EncoderResult::Success,\n        })\n    }\n    \n\n    fn rate(&self) -> u32 {\n        1\n    }\n}\n\nimpl<D> Decoder<D> for TrailingWhitespaceMethod\nwhere\n    D: Context,\n{\n    fn partial_decode(&self, context: &D) -> Result<Vec<Bit>, ContextError> {\n        let bit = if context.get_current_text()?.ends_with(ASCII_WHITESPACE) {\n            trace!(\"Found trailing whitespace\");\n            Bit(1)\n        } else {\n            Bit(0)\n        };\n        Ok(vec![bit])\n    }\n}\n\nimpl<E, D> Method<E, D> for TrailingWhitespaceMethod\nwhere\n    E: Context,\n    D: Context,\n{\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[4439136],"length":1,"stats":{"Line":2},"fn_name":"new"},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[4229507,4229050,4229514,4229132],"length":1,"stats":{"Line":4},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[4611562,4611428],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[4229509],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[4229536],"length":1,"stats":{"Line":0},"fn_name":"rate<ptero::context::PivotByLineContext>"},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":15,"coverable":17},{"path":["/","mnt","l","Projects","ptero-cli","src","method.rs"],"content":"use crate::{context::Context, decoder::Decoder, encoder::Encoder};\n\n/// Method which adds extra ASCII space when encoding bit\npub mod random_whitespace;\n\n/// Method  which puts trailing ASCII space when encoding bit\npub mod trailing_whitespace;\n\n/// Method which adds extra word when encoding bit (uses pivot, which informs about expected max line length)\npub mod line_extend;\n\n/// Method which puts trailing Unicode whitespace or invisible chars when encoding bit\npub mod trailing_unicode;\n\n/// Module containing complex methods. Complex usually means combination of several other methods.\npub mod complex;\n\n/// Combination of [Encoder](crate::encoder::Encoder) and [Decoder](crate::decoder::Decoder) traits - each method should be able to encode and decode.\npub trait Method<E, D>: Encoder<E> + Decoder<D>\nwhere\n    E: Context,\n    D: Context,\n{\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","mnt","l","Projects","ptero-cli","src","text.rs"],"content":"/// Cover text iterator which traverses the text word by word.\n/// It also enables the user to peek the word without forwarding the iterator.\n#[derive(Debug)]\npub struct CoverTextWordIterator {\n    words: Vec<String>,\n    word_index: usize,\n}\n\n/// Cover text iterator which traverses the text line by line.\n#[derive(Debug)]\npub struct CoverTextLineIterator {\n    lines: Vec<String>,\n    line_index: usize,\n}\n\nimpl CoverTextWordIterator {\n    pub fn new(cover_text: &str) -> Self {\n        CoverTextWordIterator {\n            words: cover_text\n                .split_whitespace()\n                .collect::<Vec<&str>>()\n                .iter()\n                .map(|v| v.to_string())\n                .collect(),\n            word_index: 0,\n        }\n    }\n\n    /// # Examples\n    ///\n    /// ## Returns the next word without forwarding the iterator\n    /// ```\n    /// use ptero::text::CoverTextWordIterator;\n    ///\n    /// let text = \"a b c d e;\";\n    /// let iter: CoverTextWordIterator = CoverTextWordIterator::new(&text);\n    ///\n    /// assert_eq!(iter.peek(), Some(\"a\".to_owned()));\n    /// assert_eq!(iter.peek(), Some(\"a\".to_owned()));\n    /// ```\n    pub fn peek(&self) -> Option<String> {\n        self.words\n            .get(self.word_index)\n            .map(|string| string.to_owned())\n    }\n}\n\nimpl Iterator for CoverTextWordIterator {\n    type Item = String;\n\n    /// # Examples\n    ///\n    /// ## Returns the next word\n    /// ```\n    /// use ptero::text::CoverTextWordIterator;\n    ///\n    /// let text = \"a b c\";\n    /// let mut iter: CoverTextWordIterator = CoverTextWordIterator::new(&text);\n    ///\n    /// assert_eq!(iter.next(), Some(\"a\".to_owned()));\n    /// assert_eq!(iter.next(), Some(\"b\".to_owned()));\n    /// ```\n    /// ## Returns `None` when iterator has traversed all the words and does not repeat\n    /// ```\n    /// use ptero::text::CoverTextWordIterator;\n    ///\n    /// let text = \"a b c\";\n    /// let mut iter: CoverTextWordIterator = CoverTextWordIterator::new(&text);\n    ///\n    /// assert_eq!(iter.next(), Some(\"a\".to_owned()));\n    /// assert_eq!(iter.next(), Some(\"b\".to_owned()));\n    /// assert_eq!(iter.next(), Some(\"c\".to_owned()));\n    /// assert_eq!(iter.next(), None);\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    fn next(&mut self) -> Option<Self::Item> {\n        let word = self.peek()?;\n        self.word_index += 1;\n        Some(word)\n    }\n}\n\nimpl CoverTextLineIterator {\n    pub fn new(cover_text: &str) -> Self {\n        CoverTextLineIterator {\n            lines: cover_text\n                .lines()\n                .map(|v| v.to_string())\n                .collect::<Vec<String>>(),\n            line_index: 0,\n        }\n    }\n}\n\nimpl Iterator for CoverTextLineIterator {\n    type Item = String;\n\n    /// # Examples\n    ///\n    /// ## Returns the next line\n    /// ```\n    /// use ptero::text::CoverTextLineIterator;\n    ///\n    /// let text = \"a b c\";\n    /// let mut iter: CoverTextLineIterator = CoverTextLineIterator::new(&text);\n    ///\n    /// assert_eq!(iter.next(), Some(\"a b c\".to_owned()));\n    /// ```\n    /// ## Returns `None` when traversed all the lines and does not repeat\n    /// ```\n    /// use ptero::text::CoverTextLineIterator;\n    ///\n    /// let text = \"a b c\\na\";\n    /// let mut iter: CoverTextLineIterator = CoverTextLineIterator::new(&text);\n    ///\n    /// assert_eq!(iter.next(), Some(\"a b c\".to_owned()));\n    /// assert_eq!(iter.next(), Some(\"a\".to_owned()));\n    /// assert_eq!(iter.next(), None);\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    fn next(&mut self) -> Option<Self::Item> {\n        let line = self.lines.get(self.line_index).map(|x| x.to_owned())?;\n        self.line_index += 1;\n        Some(line)\n    }\n}\n","traces":[{"line":17,"address":[4665600,4665651],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":19,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[4333056],"length":1,"stats":{"Line":2},"fn_name":"peek"},{"line":42,"address":[4665916,4665972],"length":1,"stats":{"Line":4},"fn_name":null},{"line":43,"address":[4333110],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[4666034,4666240,4666214,4666080],"length":1,"stats":{"Line":4},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":79,"address":[4333433],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[4333626],"length":1,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[4666592,4666649],"length":1,"stats":{"Line":1},"fn_name":"next"},{"line":122,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":16,"coverable":16},{"path":["/","mnt","l","Projects","ptero-cli","tests","cli_test.rs"],"content":"use log::{debug, info};\nuse std::{error::Error, fs, panic, path::PathBuf};\nuse utils::{global_setup, run_encode_command, run_decode_command};\n\nmod utils;\n\n#[test]\nfn does_not_fail_when_encoding_over_ascii_cover() -> Result<(), Box<dyn Error>> {\n    global_setup();\n    let mut res_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n    res_dir.push(\"resources\");\n    let data_path = res_dir.join(\"data.txt\");\n    let cover_path = res_dir.join(\"cover/cover_ascii.txt\");\n\n    debug!(\"Encoding to JSON format\");\n    let json_struct = run_encode_command(&cover_path, &data_path, 50, None)?;\n    assert_eq!(json_struct[\"type\"].as_str(), Some(\"success\"));\n    Ok(())\n}\n\n#[test]\nfn correctly_decodes_data_from_utf8_stego_text() -> Result<(), Box<dyn Error>> {\n    global_setup();\n    let mut res_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n    res_dir.push(\"resources\");\n    let data_path = res_dir.join(\"data.txt\");\n    let stego_path = res_dir.join(\"stego/stego_utf8.txt\");\n\n    debug!(\"Decoding to JSON format\");\n    let json_struct = run_decode_command(&stego_path, 50, None)?;\n    assert_eq!(json_struct[\"type\"].as_str(), Some(\"success\"));\n\n    debug!(\"Reading the secret data file\");\n    let data = fs::read_to_string(&data_path)?;\n\n    info!(\"Checking if decoded output starts with secret text\");\n    let has_secret_data = json_struct[\"result\"]\n        .as_str()\n        .unwrap()\n        .starts_with(data.as_str());\n    assert!(has_secret_data);\n\n    Ok(())\n}\n\n#[test]\nfn encodes_and_decodes_the_same_data() -> Result<(), Box<dyn Error>> {\n    global_setup();\n    let mut res_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n    res_dir.push(\"resources\");\n    let data_path = res_dir.join(\"data.txt\");\n    let cover_path = res_dir.join(\"cover/cover_ascii.txt\");\n    let encoding_output = PathBuf::from(\"encode_out\");\n\n    debug!(\"Encoding and saving to file\");\n    run_encode_command(&cover_path, &data_path, 50, Some(&encoding_output))?;\n\n    debug!(\"Decoding from file '{:?}' to JSON\", &encoding_output);\n    let json_struct = run_decode_command(&encoding_output, 50, None)?;\n    assert_eq!(json_struct[\"type\"].as_str(), Some(\"success\"));\n\n    debug!(\"Reading the secret data file\");\n    let data = fs::read_to_string(&data_path)?;\n\n    info!(\"Checking if decoded output starts with secret text\");\n    let has_secret_data = json_struct[\"result\"]\n        .as_str()\n        .unwrap()\n        .starts_with(data.as_str());\n    assert!(has_secret_data);\n\n    Ok(())\n}\n","traces":[{"line":8,"address":[4214960,4214969],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":9,"address":[4215111],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[4215140],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[4215161],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[4215235,4215196],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[4215287],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[4215506,4215558,4215373],"length":1,"stats":{"Line":3},"fn_name":null},{"line":16,"address":[4215907,4216004,4215697,4216099],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[4216314,4216123,4215862],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[4216275],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[4215017,4215008],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":23,"address":[4216791],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[4216820],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[4216841],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[4216915,4216876],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[4216967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[4217053,4217186,4217238],"length":1,"stats":{"Line":3},"fn_name":null},{"line":30,"address":[4217377,4217682,4217579,4217789],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[4217534,4217813,4218041],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[4218485,4217989,4218393],"length":1,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[4218673,4218833,4218970],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[4219077,4218994,4218789],"length":1,"stats":{"Line":3},"fn_name":null},{"line":37,"address":[4219240,4219388],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[4219371],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[4219440,4219477],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4219446],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[4215065,4215056],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":48,"address":[4219735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[4219764],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[4219785],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[4219820,4219859],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[4219911],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[4219997],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[4220024,4220173,4220081,4220225],"length":1,"stats":{"Line":4},"fn_name":null},{"line":56,"address":[4220784,4220372,4220658],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[4220789,4220922],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[4221410,4221208],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[4221568,4221796,4221365],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[4221744,4222148,4222240],"length":1,"stats":{"Line":3},"fn_name":null},{"line":63,"address":[4222428,4222731,4222588],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[4222544,4222755,4222838],"length":1,"stats":{"Line":3},"fn_name":null},{"line":66,"address":[4223001,4223149],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[4223132],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[4223238,4223201],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[4223207],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":45,"coverable":45},{"path":["/","mnt","l","Projects","ptero-cli","tests","utils.rs"],"content":"use std::{error::Error, path::PathBuf, sync::Once};\n\nuse assert_cmd::Command;\nuse log::LevelFilter;\nuse serde_json::Value;\n\nstatic INIT: Once = Once::new();\n\npub fn global_setup() {\n    INIT.call_once(|| {\n        fern::Dispatch::new()\n            .format(move |out, message, record| {\n                out.finish(format_args!(\n                    \"{}[{}][{}] - {}\",\n                    chrono::Local::now().format(\"[%Y-%m-%d][%H:%M:%S]\"),\n                    &record.target(),\n                    &record.level(),\n                    message,\n                ));\n            })\n            .level(LevelFilter::Trace)\n            .chain(std::io::stdout())\n            .apply()\n            .unwrap();\n    });\n}\n\npub fn run_encode_command(\n    cover_path: &PathBuf,\n    data_path: &PathBuf,\n    pivot: usize,\n    output_path: Option<&PathBuf>,\n) -> Result<Value, Box<dyn Error>> {\n    let mut cmd = Command::cargo_bin(\"ptero_cli\").unwrap();\n    if let Some(path) = output_path {\n        cmd.arg(\"-o\").arg(path);\n    } else {\n        cmd.arg(\"--json\");\n    }\n    let assert = cmd\n        .arg(\"encode\")\n        .arg(\"--eline\")\n        .arg(\"-c\")\n        .arg(&cover_path)\n        .arg(\"-d\")\n        .arg(&data_path)\n        .arg(\"--pivot\")\n        .arg(format!(\"{}\", pivot))\n        .assert()\n        .success();\n\n    let json_out = String::from_utf8_lossy(&assert.get_output().stdout);\n    let json_struct: Value = if output_path.is_some() {\n        serde_json::from_str(\"{}\")?\n    } else {\n        serde_json::from_str(&json_out)?\n    };\n\n    Ok(json_struct)\n}\n\npub fn run_decode_command(\n    stego_text: &PathBuf,\n    pivot: usize,\n    output_path: Option<&PathBuf>,\n) -> Result<Value, Box<dyn Error>> {\n    let mut cmd = Command::cargo_bin(\"ptero_cli\").unwrap();\n    if let Some(path) = output_path {\n        cmd.arg(\"-o\").arg(path);\n    } else {\n        cmd.arg(\"--json\");\n    }\n    let assert = cmd\n        .arg(\"decode\")\n        .arg(\"--eline\")\n        .arg(\"-t\")\n        .arg(&stego_text)\n        .arg(\"--pivot\")\n        .arg(format!(\"{}\", pivot))\n        .assert()\n        .success();\n\n    let json_out = String::from_utf8_lossy(&assert.get_output().stdout);\n    let json_struct: Value = if output_path.is_some() {\n        serde_json::from_str(\"{}\")?\n    } else {\n        serde_json::from_str(&json_out)?\n    };\n\n    Ok(json_struct)\n}\n","traces":[{"line":9,"address":[4215344],"length":1,"stats":{"Line":1},"fn_name":"global_setup"},{"line":10,"address":[4237448],"length":1,"stats":{"Line":3},"fn_name":null},{"line":11,"address":[4213677,4213710,4213760,4213798,4213639],"length":1,"stats":{"Line":5},"fn_name":null},{"line":12,"address":[4212873,4212752],"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":13,"address":[4213084,4212783],"length":1,"stats":{"Line":4},"fn_name":null},{"line":15,"address":[4230790,4230879],"length":1,"stats":{"Line":4},"fn_name":null},{"line":16,"address":[4230916],"length":1,"stats":{"Line":3},"fn_name":null},{"line":17,"address":[4231036,4230995],"length":1,"stats":{"Line":6},"fn_name":null},{"line":21,"address":[4231682,4231720],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[4231774,4231829,4231728],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[4215376,4215467],"length":1,"stats":{"Line":2},"fn_name":"run_encode_command"},{"line":34,"address":[4237585,4237521],"length":1,"stats":{"Line":3},"fn_name":null},{"line":35,"address":[4237765,4237613,4237664],"length":1,"stats":{"Line":3},"fn_name":null},{"line":36,"address":[4237680],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[4237637],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[4216107,4215673],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[4215909],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[4216239,4216170],"length":1,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[4216276,4216549,4216894],"length":1,"stats":{"Line":3},"fn_name":null},{"line":56,"address":[4216313,4216766,4216896,4216689],"length":1,"stats":{"Line":3},"fn_name":null},{"line":59,"address":[4216962],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[4217283,4217200],"length":1,"stats":{"Line":1},"fn_name":"run_decode_command"},{"line":67,"address":[4217241,4217305],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[4217384,4217333,4217485],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[4217400],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[4217357],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[4217863,4217489],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[4217665],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[4217926,4217995],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[4218305,4218032,4218650],"length":1,"stats":{"Line":3},"fn_name":null},{"line":87,"address":[4218445,4218069,4218652,4218522],"length":1,"stats":{"Line":6},"fn_name":null},{"line":90,"address":[4218720],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":31,"coverable":32}]}